import pefile
import re
import frida
import pefile
import math

def calculate_entropy(data):
    """Calculate the Shannon entropy of a byte sequence"""
    if not data:
        return 0

    entropy = 0
    counter = [0] * 256
    for byte in data:
        counter[byte] += 1

    for count in counter:
        if count == 0:
            continue
        p = count / len(data)
        entropy -= p * math.log2(p)

    return entropy

def is_packed(pe):
    packers = {
        "UPX": b"UPX",
        "ASPack": b"ASPack",
        "FSG": b"FSG!",
        "PECompact": b"PECompact",
        "PELock": b"PolyCrypt",
        "PESpin": b"PESpin",
        "Petite": b"petite",
        "NullsoftInstaller": b"Nullsoft",
        "InstallShield": b"IsdBnu",
        "MPRESS": b"MPRESS",
        "WWPack32": b"WWPack32",
        "MEW": b"MEW",
        "Upack": b"Upack",
        "nPack": b"NPackScrembledByNachtRachter",
        "Y0da Cryptor": b"Y0da's Cryptor",
        "EXECryptor": b"EXECryptor",
        "JDPack": b"JD-Pack",
        "EXEStealth": b"EXEstealth",
        "Molebox": b"Molebox",
        "RLPack": b"RL!",
        "PENGBuild": b"PENG",
    }

    suspicious_sections = [
        ".rdata",
        ".data",
        ".bss",
        ".tls",
        ".reloc",
    ]


    for section in pe.sections:
        data = section.get_data()
        for packer_name, packer_sig in packers.items():
            if packer_sig in data:
                return f"Packed with {packer_name}"

    section_names = [section.Name.decode().rstrip('\x00') for section in pe.sections]
    for packer_name in ["UPX", "ASPack", "FSG", "PELock", "EXECryptor", "JDPack", "RLPack", "PENGBuild", "EXEStealth", "PECompact", "WWPack32", "PESpin", "Y0da Cryptor", "Petite", "NullsoftInstaller", "Upack", "InstallShield", "MEW", "MPRESS", "Molebox"]:
        for section_name in section_names:
            if packer_name.lower() in section_name.lower():
                return f"Packed with {packer_name}"
    
    section_names_c = [section.Name.decode().rstrip('\x00') for section in pe.sections]
    for section_name_c in section_names_c:
        for suspicious_section in suspicious_sections:
            if suspicious_section.lower() in section_name_c.lower():
                return f"May not be packed but found suspicious section name: {section_name_c}"

    # Check for suspicious entry point characteristics
    suspicious_flags = [
        pefile.IMAGE_FILE_RELOCS_STRIPPED,
        pefile.IMAGE_FILE_LINE_NUMS_STRIPPED,
        pefile.IMAGE_FILE_LOCAL_SYMS_STRIPPED,
        pefile.IMAGE_FILE_DEBUG_STRIPPED,
        pefile.IMAGE_FILE_LARGE_ADDRESS_AWARE,
        pefile.IMAGE_FILE_NET_RUN_FROM_SWAP,
        pefile.IMAGE_FILE_BYTES_REVERSED_LO,
        pefile.IMAGE_FILE_BYTES_REVERSED_HI,
    ]

    # Check for suspicious characteristics
    characteristics = pe.OPTIONAL_HEADER.DllCharacteristics
    for flag in suspicious_flags:
        if characteristics & flag:
            return "Possibly packed (suspicious characteristics)"


    ep = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    ep_section = pe.get_section_by_rva(ep)

    if ep_section is not None:
        ep_section_data = ep_section.get_data()
        ep_offset = ep - ep_section.VirtualAddress

        # Check if the entry point is in a executable section
        if not ep_section.Characteristics & 0x20000000:
            return "Possibly packed (entry point in non-executable section)"

        # Check if the entry point jumps outside the section
        if ep_offset >= len(ep_section_data) or ep_offset + 5 >= len(ep_section_data):
            return "Possibly packed (entry point jumps outside section)"

        # Check for common packer jump instructions
        ep_bytes = ep_section_data[ep_offset:ep_offset+5]
        if ep_bytes[0] == 0xE9 or ep_bytes[0] == 0xE8 or (ep_bytes[0] == 0xFF and ep_bytes[1] == 0x25):
            return "Possibly packed (suspicious entry point)"

    

    # Entropy analysis
    entropy_threshold = 7.0  # Adjust this threshold as needed
    for section in pe.sections:
        data = section.get_data()
        entropy = calculate_entropy(data)
        if entropy > entropy_threshold:
            return "Possibly packed (high entropy)"

    return "Not packed"

# def dynamic_analysis(file_path):
    # try:
        # session = frida.attach(file_path)
        # script = session.create_script("""
            # Interceptor.attach(Module.getExportByName("kernel32.dll", "VirtualAlloc"), {
                # onEnter: function(args) {
                    # send("[*] VirtualAlloc called");
                # }
            # });

            # Interceptor.attach(Module.getExportByName("kernel32.dll", "VirtualProtect"), {
                # onEnter: function(args) {
                    # send("[*] VirtualProtect called");
                # }
            # });
        # """)

        # def on_message(message, data):
            # if "VirtualAlloc" in message or "VirtualProtect" in message:
                # session.detach()
                # return "Possibly packed (dynamic analysis)"

        # script.on('message', on_message)
        # script.load()
        # frida.get_remote_device().run_until_disconnected()

        # session.detach()
        # return "Not packed (dynamic analysis)"

    # except Exception as e:
        # print(f"Error during dynamic analysis: {e}")
        # return "Error during dynamic analysis"



def check_file(file_path):
    try:
        pe = pefile.PE(file_path)
        pack_result = is_packed(pe)
        # if pack_result == "Not packed":
            # dynamic_result = dynamic_analysis(file_path)
            # print(f"{file_path}: {dynamic_result}")
        # else:
        print(f"{file_path}: {pack_result}")
    except pefile.PEFormatError:
        print(f"{file_path} is not a valid PE file.")